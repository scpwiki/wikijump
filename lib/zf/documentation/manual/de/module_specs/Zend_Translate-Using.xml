<!-- EN-Revision: 12319 -->
<sect1 id="zend.translate.using">

    <title>Benutzen von Übersetzungs Adaptoren</title>

    <para>
        Der nächste Schritt ist die Benutzung des Adapters im eigenen Code.
    </para>

    <example id="zend.translate.using.example1">
        <title>Beispiel eines einsprachigen PHP Codes</title>
        <programlisting role="php"><![CDATA[
print "Beispiel\n";
print "========\n";
print "Hier steht Zeile eins\n";
print "Heute ist der " . date("d.m.Y") . "\n";
print "\n";
print "Fixe Sprache hier ist Zeile zwei\n";
]]>
        </programlisting>
    </example>

    <para>
        Das obige Beispiel zeigt eine Ausgabe ohne Unterstützung für Übersetzungen.
        Der Code wird üblicherweise in der eigenen Muttersprache geschrieben.
        Üblicherweise muß nicht nur die Ausgabe übersetzt werden, sondern auch
        Fehlermeldungen oder Logmeldungen.
    </para>

    <para>
        Der nächste Schritt ist also die Einarbeitung von Zend_Translate in den
        existierenden Code. Natürlich ist das viel einfacher wenn der Code bereits
        so geschrieben wird das er Zend_Translate benutzt anstatt das er im
        Nachhinein hierfür geändert wird.
    </para>

    <example id="zend.translate.using.example2">
        <title>Beispiel für mehrsprachigen PHP Code</title>
        <programlisting role="php"><![CDATA[
$translate = new Zend_Translate('gettext', '/my/path/source-de.mo', 'de');
$translate->addTranslation('//my/path/fr-source.mo', 'fr');

print $translate->_("Beispiel")."\n";
print "========\n";
print $translate->_("Hier steht Zeile eins")."\n";
printf($translate->_("Heute ist der %1\$s") . "\n", date("d.m.Y"));
print "\n";

$translate->setLocale('fr');
print $translate->_("Fixe Sprache hier ist Zeile zwei") . "\n";
]]>
        </programlisting>
    </example>

    <para>
        Nun nehmen wir einen tieferen Blick in was getan wurde und wie
        Zend_Translate in den eigenen Code integriert wird.
    </para>

    <para>
        Erzeugen eines neuen Objekts und Definition des Basis Adapters:

        <programlisting role="php"><![CDATA[
$translate = new Zend_Translate('gettext', '/my/path/source-de.mo', 'de');
]]>
        </programlisting>

        In diesem Beispiel wird der <emphasis role="strong">Gettext Adapter</emphasis> verwendet.
        Die Übersetzungsdatei <emphasis role="strong">source-de.mo</emphasis> wird im Verzeichnis
        <emphasis role="strong">/my/path</emphasis> platziert.
        Diese Gettext Datei beinhaltet eine deutsche Übersetzung.
        Ausserdem steht eine zweite Sprachquelle für Französisch zur Verfügung.
    </para>

    <para>
        Der nächste Schritt besteht darin alle Strings zu ummanteln die übersetzt werden sollen.
        Die einfachste Möglichkeit besteht wenn nur einfache Strings oder Sätze vorhanden sind
        wie zum Beispiel:

        <programlisting role="php"><![CDATA[
print $translate->_("Beispiel")."\n";
print "========\n";
print $translate->_("Hier ist die Zeile Eins")."\n";
]]>
        </programlisting>

        Einige Strings müssen nicht übersetzt werden. Die Trennlinie wird immer eine Trennlinie sein,
        auch in den anderen Sprachen.
    </para>

    <para>
        Variable Werte in eine Übersetzung zu integrieren wird aber auch unterstützt durch die
        Verwendung von eingebetteten Parametern.

        <programlisting role="php"><![CDATA[
printf($translate->_("Today is the %1\$s") . "\n", date("d.m.Y"));
]]>
        </programlisting>

        Statt <code>print()</code> wird die <code>printf()</code> Funktion benutzt
        und alle variablen Parameter mit <code>%1\$s</code> Blöcken ersetzt.
        Der erste ist <code>%1\$s</code>, der zweite <code>%2\$s</code>, und so weiter.
        Auf diesen Weg kann übersetzt werden ohne den exakten Wert zu wissen. In unserem
        Beispiel ist das Datum immer der aktuelle Tag, aber der String kann übersetzt
        werden ohne über den aktuellen Tag bescheid zu wissen.
    </para>

    <para>
        Jeder String wird im Übersetzungsspeicher identifiziert durch seine Message ID.
        Man könnte diese Message ID statt des Strings im Code wie folgt verwenden:

        <programlisting role="php"><![CDATA[
print $translate->_(1)."\n";
print "=======\n";
print $translate->_(2)."\n";
]]>
        </programlisting>

        Allerdings hat dies mehrere grobe Nachteile:
    </para>

    <para>
        Es ist nicht erkennbar was der Code ausgeben sollte indem man ihn betrachtet.
    </para>

    <para>
        Auch werden Probleme auftreten wenn einige Strings nicht übersetzt worden sind.
        Man muß sich immer vor Augen halten wie Übersetzungen funktionieren.
        Zuerst sieht Zend_Translate nach ob in der gesetzten Sprache für die angegebene
        Message ID oder String eine Übersetzung vorhanden ist.
        Wenn kein Übersetzung gefunden wurde, wird in der nächst tiefer gelegenen
        Sprache gesucht wie in Zend_Locale definiert.
        "<emphasis role="strong">de_AT</emphasis>" wird also zu
        "<emphasis role="strong">de</emphasis>".
        Wenn auch hier keine Übersetzung in der Sprache "<emphasis role="strong">de</emphasis>"
        gefunden wurde, wird der Original String zurück gegeben.
        Das bedeutet also das immer eine Ausgabe existiert, selbst wenn für eine Message ID
        keine Übersetzung in der Quelle vorhanden ist.
        Zend_Translate wird niemals eine Exception oder einen Fehler ausgeben wenn ein
        String übersetzt werden soll.
    </para>

    <sect2 id="zend.translate.using.structure">

        <title>Strukturen für Übersetzungdateien</title>

        <para>
            Der nächste Schritt besteht in der Erstellung der Übersetzungsdateien für die
            verschiedenen Sprachen welche zu übersetzen sind.
            Für jeden Adapter gibt es eine andere Art und Weise die hier beschrieben ist.
            Aber es gibt ein paar generelle Features die für alle Adaptoren relevant sind.
        </para>

        <para>
            Zuerst muß überlegt werden wo die Übersetzung Dateien gespeichert werden.
            Mit Zend_Translate bestehen hierbei keinerlei Einschränkungen.
            Trotzdem sollten die folgenden Strukturen bevorzugt verwendet werden:
        </para>

        <itemizedlist>
            <listitem>
                <para>
                    Einzeln strukturierte Quellen
                </para>

                <programlisting><![CDATA[
/application
/languages
  lang.en
  lang.de
/library
]]>
                </programlisting>

                <para>
                    Positiv: Alle Quell Dateien jeder Sprache sind in einem Verzeichnis
                    zu finden. Keine Aufteilung der relevanten Dateien.
                </para>
            </listitem>
            <listitem>
                <para>
                    Sprachlich stukturierte Quellen
                </para>

                <programlisting><![CDATA[
/application
/languages
  /en
    lang.en
    other.en
  /de
    lang.de
    other.de
/library
]]>
                </programlisting>

                <para>
                    Positiv: Jede Sprache ist in einem einzelnen Verzeichnis zu finden.
                    Jede Sprache hat sein eigenes Verzeichnis und kann durch ein eigenes
                    Übersetzungsteam bearbeitet werden. Ausserdem ist die Verwendung von
                    mehreren Dateien genauso transparent.
                </para>
            </listitem>
            <listitem>
                <para>
                    Applikations strukturierte Quellen
                </para>

                <programlisting><![CDATA[
/application
  /languages
    lang.en
    lang.de
    other.en
    other.de
]]>
                </programlisting>

                <para>
                    Positiv: Alle Quell Dateien für jede Sprache können in einem
                    einzelnen Verzeichnis gefunden werden. Keine Aufteilung der
                    relevanten Dateien.
                </para>

                <para>
                    Negativ: Die Benutzung von mehreren Datein für die selbe
                    Sprache ist problematisch.
                </para>
            </listitem>
            <listitem>
                <para>
                    Gettext strukturierte Quellen
                </para>

                <programlisting><![CDATA[
/languages
  /de
    /LC_MESSAGES
      lang.mo
      other.mo
  /en
    /LC_MESSAGES
      lang.mo
      other.mo
]]>
                </programlisting>

                <para>
                    Positiv: Alte Gettext Quellen können ohne Veränderung der
                    Struktur benutzt werden.
                </para>

                <para>
                    Negativ: Die Benutzung von Sub-Sub Verzeichnissen ist verwirrend
                    für Personen die Gettext noch nie benutzt haben.
                </para>
            </listitem>
            <listitem>
                <para>
                    Datei strukturierte Quellen
                </para>

                <programlisting><![CDATA[
/application
  /models
    mymodel.php
    mymodel.de
    mymodel.en
  /views
  /controllers
    mycontroller.de
/document_root
  /images
  /styles
  .htaccess
  index.php
  index.de
/library
  /Zend
]]>
                </programlisting>
                <para>
                    Positiv: Jede Datei ist bei Ihrer Übersetzung zu finden
                    source.
                </para>

                <para>
                    Negativ: Mehrfache kleine Übersetzungs Quellen machen die
                    Übersetzung sehr schwer.
                    Ausserdem muß jede Datei als Übersetzung Quelle hinzugefügt werden.
                </para>
            </listitem>
        </itemizedlist>

        <para>
            Einzeln strukturierte und sprachlich strukturierte Quell Dateien sind
            für Zend_Translate am besten benutzbar.
        </para>

        <para>
            Also jetzt, da bekannt ist welche Struktur verwendet wird,
            müssen die einzelnen Übersetzungs Dateien erstellt werden.
        </para>

    </sect2>

    <sect2 id="zend.translate.using.source.array">

        <title>Erzeugung von Array Quellen</title>

        <para>
            Array Quellen sind einfache Array. Aber sie müssen per Hand definiert
            werden da es hierfür keine Tools gibt.
            Weil Sie so einfach zu handhaben sind, ist Ihre Verwendung auch der
            schnellste Weg um zu testen ob Nachrichten innerhalb des Codes wie
            erwartet arbeiten. Es ist generell der beste Adapter um mit
            Mehrsprachigkeit zu beginnen wenn man keine diesbezüglichen Kenntnisse hat.
        </para>

        <programlisting role="php"><![CDATA[
$english = array('message1' => 'message1',
                 'message2' => 'message2',
                 'message3' => 'message3');
$german = array('message1' => 'Nachricht1',
                'message2' => 'Nachricht2',
                'message3' => 'Nachricht3');

$translate = new Zend_Translate('array', $english, 'en');
$translate->addTranslation($deutsch, 'de');
]]>
        </programlisting>

        <para>
            Seit Release 1.5 wird es auch unterstützt, das Array die in externen Dateien vorhanden sind zu
            inkludieren. Es muß nur der Dateiname angegeben werden und <code>Zend_Translate</code> wird
            diesen automatisch inkludieren und nach dem Array schauen. Das folgende Beispiel zeigt Details:
        </para>

        <programlisting role="php"><![CDATA[
// myarray.php
<?php
return array(
    'message1' => 'Nachricht1',
    'message2' => 'Nachricht2',
    'message3' => 'Nachricht3');

// controller
$translate = new Zend_Translate('array', 'path/to/myarray.php', 'de');
]]>
        </programlisting>

        <note>
            <para>
                Bei Dateien die kein Array zurückgeben wird das inkludieren fehlschlagen. Auch jegliche
                Ausgabe innerhalb dieser Dateien wird ignoriert und unterdrückt.
            </para>

        </note>

    </sect2>

    <sect2 id="zend.translate.using.source.gettext">

        <title>Erstellung von Gettext Quellen</title>

        <para>
            Gettext Quellen werden durch GNU's Gettext Bibliothek erstellt.
            Es gibt einige kostenlose Tools welche den Code parsen können und hierbei
            die gewünschten Gettext Quellen erstellen.
            Diese Dateien haben die Endung <emphasis role="strong">*.mo</emphasis>
            und sind binäre Dateien. Ein kostenloses Programm für die Erstellung der
            Quellen ist <ulink url="http://sourceforge.net/projects/poedit/">poEdit</ulink>.
            Dieses Tool unterstützt auch beim Übersetzungs Prozess selbst.
        </para>

        <programlisting role="php"><![CDATA[
// Wir nehmen an das die mo Datien erstellt und übersetzt wurden
$translate = new Zend_Translate('gettext', 'path/to/english.mo', 'en');
$translate->addTranslation('path/to/german.mo', 'de');
]]>
        </programlisting>

        <para>
            Wie man sieht wird dieser Adapter auf exakt die gleiche Art und Weise
            verwendet mit einer kleinen Änderung. Den Tausch von 'array' zu 'gettext'.
            Alle anderen Punkte werden in jedem anderen Adapter auf exakt die
            gleiche Weise verwendet. Mit diesem Gettext Adapter muß nicht mehr auf
            die geforderte Standard Verzeichnis Struktur von Gettext geachtet werden.
            Auch nicht auf bindtextdomain und textdomain.
            Nur der Pfad und der Dateiname muß dem Adapter übergeben werden.
        </para>

        <note>
            <para>
                 Man sollte immer UTF-8 als Quell Encoding verwenden.
                 Man könnte sonst Probleme bekommen wenn man zwei verschiedene
                 Encodings verwendet. Wenn zum Beispiel eine Quell Datei mit
                 ISO-8815-11 und eine andere mit CP815 encoded ist.
                 Man kann immer nur ein Encoding für alle Quell Dateien verwenden,
                 und hierbei würde eine der gewünschten Sprachen nicht korrekt
                 angezeigt werden.
            </para>
            <para>
                 UTF-8 ist ein portables Format welches alle Sprachen unterstützt.
                 Wenn man also UTF-8 für alle Sprachen verwendet, eliminiert man die
                 Probleme mit inkompatiblen Encodings.
            </para>
        </note>

        <para>
            Viele Gettext Editoren fügen Informationen über den Adapter als Übersetzung eines leeren
            Strings hinzu. Das ist der Grund warum ein leerer String nicht übersetzt werden wenn der
            Gettext Adapter verwendet wird. Stattdessen wird er von der Übersetzungstabelle gelöscht und
            von der <code>getAdapterInfo()</code> Methode angeboten. Sie gibt die Adapterinformationen für
            alle hinzugefügten Gettextdateien als Array zurück wobei der Dateiname als Schlüssel verwendet
            wird.
        </para>

        <programlisting role="php"><![CDATA[
// Wie man Informationen des Adapters erhält
$translate = new Zend_Translate('gettext', 'path/to/english.mo', 'en');
print_r $translate->getAdapterInfo();
]]>
        </programlisting>

    </sect2>

    <sect2 id="zend.translate.using.source.tmx">

        <title>Erstellung von TMX Quellen</title>

        <para>
            TMX Quellen sind der neue Industrie Standard. Sie haben den Vorteil
            das sie XML Dateien sind und deswegen mit jedem Texteditor und
            natürlich auch von Menschen direkt lesbar. Man kann TMX Dateien entweder
            per Hand erstellen oder man verwendet Tools dafür. Allerdings sind die
            meisten erhältlichen Tools die TMX Quellen erstellen können nicht kostenlos.
        </para>

        <example id="zend.translate.using.source.tmx.example">
            <title>Beispiel einer TMX Datei</title>
            <programlisting role="xml"><![CDATA[
<?xml version="1.0" ?>
<!DOCTYPE tmx SYSTEM "tmx14.dtd">
<tmx version="1.4">
 <header creationtoolversion="1.0.0" datatype="winres" segtype="sentence"
         adminlang="en-us" srclang="de-at" o-tmf="abc"
         creationtool="XYZTool" >
 </header>
 <body>
  <tu tuid='message1'>
   <tuv xml:lang="de"><seg>Nachricht1</seg></tuv>
   <tuv xml:lang="en"><seg>message1</seg></tuv>
  </tu>
  <tu tuid='message2'>
   <tuv xml:lang="en"><seg>message2</seg></tuv>
   <tuv xml:lang="de"><seg>Nachricht2</seg></tuv>
  </tu>
]]>
            </programlisting>

            <programlisting role="php"><![CDATA[
$translate = new Zend_Translate('tmx', 'path/to/mytranslation.tmx', 'en');
// TMX kann mehrere Sprachen in einer einzigen TMX Datei enthalten.
]]>
            </programlisting>
        </example>

        <para>
            TMX Dateien können mehrere Sprachen in der selben Datei enthalten.
            Alle anderen in der Quelle enthaltenen Sprachen werden automatisch
            hinzugefügt und müssen nicht durch einen extra Aufruf von <code>addLanguage()</code>
            ergänzt werden.
        </para>

        <para>
            Wenn man nur spezielle Sprache aus der Quelle übersetzen will, kann  die Option
            <code>defined_language</code> auf <code>true</code> gesetzt werden. Mit dieser
            Option können gewünschte Sprachen explizit mit <code>addLanguage()</code>
            hinzugefügt werden. Der Standardwert für diese Option fügt alle Sprachen hinzu.
        </para>
    </sect2>

    <sect2 id="zend.translate.using.source.csv">

        <title>Erstellung von CSV Quellen</title>

        <para>
            CSV Quellen sind sehr klein und von Menschen lesbar. Wenn ein Kunde selbst übersetzen
            will, ist die Verwendung des CSV Adapters warscheinlich die beste Wahl.
        </para>

        <example id="zend.translate.using.source.csv.example">
            <title>Beispiel CSV Datei</title>
            <programlisting><![CDATA[
﻿#Example csv file
message1;Nachricht1
message2;Nachricht2
]]>
            </programlisting>

            <programlisting role="php"><![CDATA[
$translate = new Zend_Translate('csv', 'path/to/mytranslation.csv', 'de');
$translate->addTranslation('path/to/other.csv', 'fr');
]]>
            </programlisting>
        </example>

        <para>
            Es gibt drei verschiedene Optionen für den CSV Adapter. Es können
            <code>'delimiter'</code>, <code>'limit'</code> und <code>'enclosure'</code>
            gesetzt werden.
        </para>

        <para>
            Das Standard Trennzeichen für CSV Strings ist das '<code>;</code> Zeichen.
            Aber es muß nicht dieses Zeichen sein. Mit der Option '<code>delimiter</code>'
            kann ein anderes Trennzeichen ausgesucht werden.
        </para>

        <para>
            Das Standardlimit für eine Zeile in einer CSV Datei ist '<code>0</code>'.
            Das bedeutet das das Ende der CSV Zeile automatisch gesucht wird. Wenn die
            '<code>limit</code>' auf irgendeinen Wert gesetzt wird, dann wird die CSV
            Datei schneller gelesen, aber jede Zeile die dieses Limit überschreitet wird
            abgeschnitten.
        </para>

        <para>
            The default enclosure to use for CSV files is '<code>"</code>'. You can
            set a different one with the option '<code>enclosure</code>'.
        </para>

        <example id="zend.translate.using.source.csv.example2">
            <title>Beispiel 2 für CSV Dateien</title>
            <programlisting><![CDATA[
﻿# Example csv file
# original 'message,1'
"message,1",Nachricht1
# translation 'Nachricht,2'
message2,"Nachricht,2"
# original 'message3,'
"message3,",Nachricht3
]]>
            </programlisting>

            <programlisting role="php"><![CDATA[
$translate = new Zend_Translate('csv',
                                'path/to/mytranslation.csv',
                                'de',
                                array('delimiter' => ','));
$translate->addTranslation('path/to/other.csv', 'fr');
]]>
            </programlisting>
        </example>

    </sect2>

    <sect2 id="zend.translate.using.source.ini">

        <title>Erstellung von INI Quelldateien</title>

        <para>
            INI Quelldateien sind menschlich lesbar aber normalerweise nicht sehr klein da Sie neben der
            Übersetzung auch andere Daten enthalten. Wenn Sie Daten haben die von Ihrem Kunden bearbeitet
            werden sollten können Sie auch den INI Adapter für diesen Zweck verwenden.
        </para>

        <example id="zend.translate.using.source.ini.example">
            <title>Beispiel einer INI Datei</title>
            <programlisting><![CDATA[
[Test]
;TestPage Comment
Message_1="Nachricht 1 (de)"
Message_2="Nachricht 2 (de)"
Message_3="Nachricht :3 (de)"
]]>
            </programlisting>

            <programlisting role="php"><![CDATA[
$translate = new Zend_Translate('ini', 'path/to/mytranslation.ini', 'de');
$translate->addTranslation('path/to/other.ini', 'it');
]]>
            </programlisting>
        </example>

        <para>
            INI Dateien haben diverse Einschränkungen. Wenn ein Wert in einer INI Datei irgendein nicht
            alphanummerisches Zeichen enthält, muß er in doppelte Anführungszeichen (") eingeklammert werden.
            Es gibt auch reservierte Wörter welche nicht als Schlüssel für INI Dateien verwendet werden
            dürfen. Diese enthalten: null, no, true und false. Die Werte null, no und false führen zu "",
            yes und true resultieren in "1". Die Zeichen {}|&amp;~![()" dürfen nirgendwo im Schlüssel
            verwendet werden und haben im Wert eine spezielle Bedeutung. Sie sollten nicht verwendet werden
            da sie sonst zu unerwartetem Verhlaten führen können.
        </para>

    </sect2>

    <sect2 id="zend.translate.using.options">

        <title>Optionen für Adapter</title>

        <para>
            Optionen können bei allen Adaptoren verwendet werden. Natürlich sind die Optionen für alle
            Adaptoren verschieden. Die Optionen können bei Erstellung des Objekts miterstellt werden.
            Zur Zeit gibt es nur eine Option die für alle Adaptoren verfügbar ist. '<code>clear</code>'
            entscheidet ob die neuen Übersetzungsdaten zu den bestehenden hinzugefügt werden sollen oder
            ob Sie diese überschreiben. Das Standardverhalten ist das Hinzufügen von neuen Übersetzungsdaten
            zu bestehenden. Aber das wird immer nur für die aktuelle Sprache gemacht. Alle anderen Sprachen
            werden nicht verändert.
        </para>

        <para>
            Man kann Optionen temporär setzen indem man die Funktion
            <code>addTranslation($data, $locale, array $options = array())</code> als dritten und optionalen
            Parameter benutzt. Ausserdem kann die Funktion <code>setOptions()</code> benutzt werden um
            Optionen fix zu setzen.
        </para>

        <example id="zend.translate.using.options.example">
            <title>Benutzen von Übersetzungsoptionen</title>
            <programlisting role="php"><![CDATA[
// Definiere ':' als Trenner für die Quelldatei der Übersetzung
$options = array('separator' => ':');
$translate = new Zend_Translate('csv',
                                'path/to/mytranslation.csv',
                                'de',
                                $options);

...

// Lösche die definierte Sprache und verwende die neuen Übersetzungsdaten
$options = array('clear' => true);
$translate->addTranslation('path/to/new.csv', 'fr', $options);
]]>
            </programlisting>
        </example>

        <para>
            Hier können alle vorhandenen Optionen für die verschiedenen Adapter gefunden werden mit einer
            Beschreibung Ihrer Verwendung:
        </para>

        <table id="zend.translate.using.options.alloptions">
            <title>Optionen für Übersetzungs-Adapter</title>
            <tgroup cols="4">
                <thead>
                    <row>
                        <entry>Adapter</entry>
                        <entry>Option</entry>
                        <entry>Standard Wert</entry>
                        <entry>Beschreibung</entry>
                    </row>
                </thead>
                <tbody>
                    <row>
                        <entry>all</entry>
                        <entry>clear</entry>
                        <entry><emphasis role="strong">false</emphasis></entry>
                        <entry>Wenn true gesetzt wird, werden bereits gelesene Übersetzungen entfernt. Das kann
                        statt dem Erstellen einer neuen Instanz verwendet werden wenn neue Übersetzungsdaten
                        gelesen werden</entry>
                    </row>
                    <row>
                        <entry>all</entry>
                        <entry>disableNotices</entry>
                        <entry><emphasis role="strong">false</emphasis></entry>
                        <entry>Wenn es auf true gesetzt wird, werden alle Notizen betreffend nicht vorhandenen
                        Übersetzungen ausgeschaltet. Man sollte diese Option in einer Produktionsumgebung auf
                        true setzen</entry>
                    </row>
                    <row>
                        <entry>all</entry>
                        <entry>ignore</entry>
                        <entry><emphasis role="strong">.</emphasis></entry>
                        <entry>Alle Verzeichnisse und Dateien die mit diesem Präfix beginnen werden bei der
                        Suche nach Dateien ignoriert. Der Standardwert ist
                        <emphasis role="strong">'.'</emphasis> was zu dem Verhalten führt das alle
                        versteckten Dateien ignoriert werden. Wenn dieser Wert auf 'tmp' gesetzt wird, bedeutet
                        das, das Verzeichnisse und Dateien wie z.B. 'tmpImages' und 'tmpFiles', sowie alle
                        darunter liegenden Verzeichnisse, ignoriert werden.</entry>
                    </row>
                    <row>
                        <entry>all</entry>
                        <entry>scan</entry>
                        <entry><emphasis role="strong">null</emphasis></entry>
                        <entry>Wenn null gesetzt wird, wird die Verzechnisstruktur nicht gescannt.
                        Wenn Zend_Translate::LOCALE_DIRECTORY gesetzt wird, wird das Gebietsschema im
                        Verzeichnis gesucht. Wenn Zend_Translate::LOCALE_FILENAME gesetzt wird, wird das
                        Gebietsschema im Dateinamen gesucht. Siehe
                        <xref linkend="zend.translate.using.detection" /> für Details</entry>
                    </row>
                    <row>
                        <entry>Csv</entry>
                        <entry>delimiter</entry>
                        <entry><emphasis role="strong">;</emphasis></entry>
                        <entry>Definiert welches Zeichen als Trenner für Quelle und Übersetzung verwendet wird</entry>
                    </row>
                    <row>
                        <entry>Csv</entry>
                        <entry>length</entry>
                        <entry><emphasis role="strong">0</emphasis></entry>
                        <entry>Definiert die maximale Länge einer CSV Zeile. Auf 0 gesetzt wird sie automatisch erkannt</entry>
                    </row>
                    <row>
                        <entry>Csv</entry>
                        <entry>enclosure</entry>
                        <entry><emphasis role="strong">"</emphasis></entry>
                        <entry>Definiert das zu verwendende Einschließungszeichen. Standard ist das doppelte Hochkomma</entry>
                    </row>
                </tbody>
            </tgroup>
        </table>

        <para>
            Wenn man selbstdefinierte Optionen haben will, können diese auch in allen Adaptern verwendet werden.
            Die <code>setOptions()</code> Methode kann verwendet werden um die eigene Option zu definieren.
            <code>setOptions()</code> benötigt ein Array mit den Optionen die gesetzt werden sollen. Wenn eine
            angegebene Option bereits existiert wird diese überschrieben. Es können beliebig viele Optionen
            definiert werden da diese nicht vom Adapter geprüft werden. Es muß nur sichergestellt werden das keine
            bereits existierende Option überschrieben wird welche ein Adapter verwendet.
        </para>

        <para>
            Um die gesetzte Option zurückzugeben kann die Methode <code>getOptions()</code> verwendet werden. Wenn
            <code>getOptions()</code> ohne einen Parameter aufgerufen wird, gibt Sie alle Optionen zurück. Wenn
            der optionale Parameter angegeben wird, wird nur diese spezielle Option zurückgegeben.
        </para>

    </sect2>

    <sect2 id="zend.translate.using.languages">

        <title>Mit Sprachen arbeiten</title>

        <para>
            Wenn mit verschiedenen Sprachen gearbeitet wird gibt es ein paar Methoden die nützlich sind.
        </para>

        <para>
            Die <code>getLocale()</code> Methode kann verwendet werden um die aktuell gesetzte Sprache zu
            erhalten. Sie kann entweder eine Instanz von <code>Zend_Locale</code> oder den Bezeichner des
            Gebietsschemas enthalten.
        </para>

        <para>
            Die <code>setLocale()</code> Methode setzt eine neue Standardsprache für Übersetzungen. Das verhindert
            das der optionale Sprachparameter der <code>translate()</code> Methode mehr als einmal gesetzt werden
            muß. Wenn die angegebene Sprache nicht existiert, oder keine Übersetzten Daten für diese Sprache
            vorhanden sind, versucht <code>setLocale()</code> auf die Sprache ohne Region downzugraden wenn diese
            angegeben wurde. Die Sprache <code>en_US</code> würde zum Beispiel zu  <code>en</code> downgegradet
            werden. Wenn auch nach dem Downgraden die Sprache nicht gefunden werden konnte, wird eine
            Ausnahme geworfen.
        </para>

        <para>
            Die <code>isAvailable()</code> Methode prüft ob eine angegebene Sprache bereits vorhanden ist. Es wird
            <code>true</code> zurückgegeben wenn Daten für die angegebene Sprache existieren.
        </para>

        <para>
            Und letztendlich kann die <code>getList()</code> Methode verwendet werden um alle aktuell gesetzten
            Sprachen für einen Adapter als Array zurückgegeben zu bekommen.
        </para>

        <example id="zend.translate.using.languages.example">
            <title>Handhabung von Sprachen mit Adaptern</title>
            <programlisting role="php"><![CDATA[
...
// gibt die aktuell gesetzte Sprache zurück
$actual = $translate->getLocale();

...
// der optionale Parameter kann wärend der Übersetzung verwendet werden
echo $translate->_("mein_Text", "fr");
// oder es wird eine neue Standardsprache gesetzt
$translate->setLocale("fr");
echo $translate->_("mein_Text");
// zur Basissprache referieren... fr_CH wird zu fr downgegradet und
// verwendet
$translate->setLocale("fr_CH");
echo $translate->_("mein_Text");

...
// Prüft ob die Sprache existiert
if ($translate->isAvailable("fr")) {
    // Sprache existiert
}
]]>
            </programlisting>
        </example>

        <sect3 id="zend.translate.using.languages.automatic">

            <title>Automatische Handhabung von Sprachen</title>

            <para>
                Es gilt zu beachten das, solange man neue Sprachquellen mit der <code>addTranslation()</code>
                Methode hinzufügt, <code>Zend_Translate</code> automatisch die am besten passende Sprache für
                die eigene Umgebung auswählt wenn man eine der automatischen Gebietsschemata verwendet die
                'auto' oder 'browser' sein können. Man muß normalerweise also <code>setLocale()</code> nicht
                aufrufen. Das sollte nur in Verbindung mit der automatischen Erkennung von Quellen verwendet
                werden.
            </para>

            <para>
                Der Algorithmus sucht nach dem am besten passenden Gebietsschema abhängig vom Browser des
                Benutzers und der eigenen Umgebung. Siehe das folgende Beispiel für Details:
            </para>

            <example id="zend.translate.using.languages.automatic.example">
                <title>Wie das automatische Erkennen der Sprache funktioniert</title>
                <programlisting role="php"><![CDATA[
// Angenommen der Browser gibt folgende Spracheneinstellungen zurück
// HTTP_ACCEPT_LANGUAGE = "de_AT=1;fr=1;en_US=0.8";

// Beispiel 1:
$translate = new Zend_Translate('gettext',
                                '\my_it.mo',
                                'auto',
                                array('scan' => Zend_Translate::LOCALE_FILENAME));
// keine passende Sprache gefunden, die MessageID wird zurückgegeben

// Beispiel 2:
$translate = new Zend_Translate('gettext',
                                '\my_fr.mo',
                                'auto',
                                array('scan' => Zend_Translate::LOCALE_FILENAME);
// Die am besten passende Sprache ist 'fr'

// Beispiel 3:
$translate = new Zend_Translate('gettext',
                                '\my_de.mo',
                                'auto',
                                array('scan' => Zend_Translate::LOCALE_FILENAME);
// Die am besten passende Sprache ist 'de' weil 'de_AT' zu 'de'
// degradiert wird

// Beispiel 4:
$translate = new Zend_Translate('gettext',
                                '\my_it.mo',
                                'auto',
                                array('scan' => Zend_Translate::LOCALE_FILENAME);
$translate->addTranslation('\my_ru.mo', 'ru');
$translate->setLocale('it_IT');
// gibt 'it' als Übersetzungsquelle zurück und überschreibt die automatischen Eigenschaften
]]>
                </programlisting>
            </example>

            <para>
                Nachdem eine Sprache per Hand mit der <code>setLocale()</code> Methode gesetzt wurde, wird
                die automatische Erkennung ausgeschaltet und übergangen.
            </para>

            <para>
                Wenn man die Automatik wieder verwenden will, kann die Sprache
                <emphasis role="strong">auto</emphasis> mit <code>setLocale()</code> gesetzt werden, was die
                automatische Erkennung für <code>Zend_Translate</code> wieder reaktiviert.
            </para>

            <para>
                Seit dem Zend Framework 1.7.0 unterstützt <code>Zend_Translate</code> auch die Verwendung eines
                Anwendungsweiten Gebietsschemas. Man kann einfach eine <code>Zend_Locale</code> Instanz in der
                Registry setzen wie unten gezeigt. Mit dieser Schreibweise kann man das manuelle Setzen eines
                Gebietsschemas mit jeder Instanz komplett vergessen wenn man das gleiche Gebietsschema mehrere
                Male verwenden will.
            </para>

            <programlisting role="php"><![CDATA[
// In der Bootstrap Datei
$locale = new Zend_Locale();
Zend_Registry::set('Zend_Locale', $locale);

// Standardsprache wenn die angefragte Sprache nicht vorhanden ist
$defaultlanguage = 'en';

// Irgendwo in der Anwendung
$translate = new Zend_Translate('gettext', '\my_de.mo');
if (!$translate->isAvailable($locale->getLanguage())) {
    // Wenn der Benutzer eine nicht vorhandene Sprache anfragt auf den Standard umrouten
    $translate->setLocale($defaultlanguage);
}

$translate->getLocale();
]]>
            </programlisting>

        </sect3>

    </sect2>

    <sect2 id="zend.translate.using.detection">

        <title>Automatische Erkennung von Quellen</title>

        <para>
            Zend_Translate kann Übersetzungsquellen automatisch erkennen. Es muß also nicht jede Quelldatei
            manuell deklariert werden. Man kann diesen Job Zend_Translate überlassen welches die komplette
            Verzeichnisstruktur nach Quelldateien durchsucht.
        </para>

        <note>
            <para>
                Automatische Erkennung der Quellen ist seit Zend Framework Version 1.5 vorhanden.
            </para>
        </note>

        <para>
            Die Verwendung ist fast die selbe wie bei der Initiierung einer einzelnen Übersetzungsquelle
            mit einem Unterschied. Es darf nur ein Verzeichnis angegeben werden, statt einer Datei, welches
            gescannt werden soll.
        </para>

        <example id="zend.translate.using.languages.directory.example">
            <title>Scannen nach Quellen in einer Verzeichnisstruktur</title>
            <programlisting role="php"><![CDATA[
// Angenommen wir haben die folgende Struktur
//  /language
//  /language/login/login.tmx
//  /language/logout/logout.tmx
//  /language/error/loginerror.tmx
//  /language/error/logouterror.tmx

$translate = new Zend_Translate('tmx', '/language');
]]>
            </programlisting>
        </example>

        <para>
            Zend_Translate muß also nicht nur das angegebene Verzeichnis durchsuchen, sondern auch alle
            Unterverzeichnisse nach Dateien für Übersetzungsen. Das macht die Verwendung sehr einfach.
            Aber Zend_Translate wird alle Dateien ignorieren, welche keine Quellen sind, oder wärend des
            Einlesens der Übersetzungsdaten Fehler produzieren. Man sollte also sicherstellen das alle
            Übersetzungsquellen korrekt sind und gelesen werden können weil man keinen Fehler erhält wenn
            eine Datei fehlerhaft ist oder nicht gelesen werden kann.
        </para>

        <note>
            <para>
                Abhängig davon wie tief die Verzeichnisstruktur ist und wieviele Dateien innerhalb dieser
                Struktur vorhanden sind, kann es eine sehr lange Zeit dauern bis Zend_Translate fertig ist.
            </para>
        </note>

        <para>
            In unserem Beispiel haben wir das TMX Format verwendet welches die Sprache enthält die innerhalb
            der Quelle verwendet wird. Aber viele der anderen Quellformate sind nicht dazu fähig die Sprache
            in der Datei selbst zu inkludieren. Aber auch diese quellen können mit der automatischen
            Erkennung verwendet werden wenn ein paar Dinge berücksichtigt werden die anbei beschrieben sind:
        </para>

        <sect3 id="zend.translate.using.detection.directory">

            <title>Sprachen durch die Benennung von Verzeichnissen</title>

            <para>
                Ein Weg, die automatische Spracherkennung zu inkludieren, ist es die Verzechnisse relativ zur
                Sprache zu benennen, welche in den Quellen des betreffenden Verzechnisses verwendet wird. Das
                ist der einfachste Weg und wird zum Beispiel in Standard Gettext Implementationen verwendet.
            </para>

            <para>
                Zend_Translate benötigt die 'scan' Option um zu wissen das es die Namen aller Verzeichnisse
                nach Sprachen durchsuchen soll. Siehe das folgende Beispiel für Details:
            </para>

            <example id="zend.translate.using.detection.directory.example">
                <title>Verzeichnisse nach Sprachen durchsuchen</title>
                <programlisting role="php"><![CDATA[
// Angenommen wir haben die folgende Struktur
//  /language
//  /language/de/login/login.mo
//  /language/de/error/loginerror.mo
//  /language/en/login/login.mo
//  /language/en/error/loginerror.mo

$translate = new Zend_Translate('gettext',
                                '/language',
                                null,
                                array('scan' =>
                                      Zend_Translate::LOCALE_DIRECTORY));
]]>
                </programlisting>
            </example>

            <note>
                <para>
                    Das funktioniert nur für Adapter die die Sprache nicht in der Quelldatei enthalten. Die
                    Verwendung dieser Option wird zum Beispiel mit TMX ignoriert. Sprachdefinitionen im
                    Dateinamen werden bei der Verwendung dieser Option ignoriert.
                </para>
            </note>

            <note>
                <para>
                    Man sollte acht geben wenn man verschiedenen Unterverzeichnisse in der gleichen
                    Struktur hat. Angenommen wir haben eine Struktur wie
                    <code>/language/module/de/en/file.mo</code>. Der Pfad enthält in diesem Fall
                    mehrere Strings die als Gebietsschema erkannt werden würden. Das könnte
                    entweder <code>de</code> oder <code>en</code> sein. Da das Verhalten, in diesem
                    Fall, unbestimmt ist sollte in solchen Situationen die Dateierkennung
                    verwendet werden.
                </para>
            </note>

        </sect3>

        <sect3 id="zend.translate.using.detection.filename">

            <title>Sprache durch Dateinamen</title>

            <para>
                Ein anderer Weg um die Sprache automatisch zu erkennen ist die Verwendung von speziellen
                Dateienamen. Man kann entweder die komplette Datei oder Teile der Datei nach der verwendeten
                Sprache benennen. Um diese Option zu Verwenden muß die 'scan' Option bei der Initiierung
                gesetzt werden. Es gibt verschiedene Wege die Quelldateien zu benennen welche im folgenden
                beschrieben werden:
            </para>

            <example id="zend.translate.using.detection.filename.example">
                <title>Suchen nach Sprachen im Dateinamen</title>
                <programlisting role="php"><![CDATA[
// Angenommen wir haben die folgende Struktur
//  /language
//  /language/login/login_en.mo
//  /language/login/login_de.mo
//  /language/error/loginerror_en.mo
//  /language/error/loginerror_de.mo

$translate = new Zend_Translate('gettext',
                                '/language',
                                null,
                                array('scan' =>
                                      Zend_Translate::LOCALE_FILENAME));
]]>
                </programlisting>
            </example>

            <sect4 id="zend.translate.using.detection.filename.complete">

                <title>Komplette Dateinamen</title>

                <para>
                    Die komplette Datei nach der Sprache zu benennen ist der einfachste weg, aber nur
                    praktikabel wenn nur eine Datei pro Verzeichnis verwendet wird.
                </para>

                <programlisting><![CDATA[
/languages
  en.mo
  de.mo
  es.mo
]]>
                </programlisting>

            </sect4>

            <sect4 id="zend.translate.using.detection.filename.extension">

                <title>Erweiterung der Datei</title>

                <para>
                    Ein anderer sehr einfacher Weg ist die Verwendung der Dateiextension für die
                    Spracherkennung. Aber das kann verwirrend sein weil die ursprügliche verwendete
                    Dateiextension nicht mehr vorhanden ist.
                </para>

                <programlisting><![CDATA[
/languages
  view.en
  view.de
  view.es
]]>
                </programlisting>

            </sect4>

            <sect4 id="zend.translate.using.detection.filename.token">

                <title>Teile von Dateinamen</title>

                <para>
                    Zend_Translate kann die Sprache auch erkennen wenn Sie im Dateinamen enthalten ist.
                    Aber wenn dieser Weg verwendet wird, muß die Sprache mit einem Trennzeichen seperiert
                    werden. Es gibt drei unterstützte Trennzeichen welche verwendet werden können. Ein Punkt
                    '.', ein Unterstrich '_', oder ein Bindestrich '-'.
                </para>

                <programlisting><![CDATA[
/languages
  view_en.mo  -> erkennt englisch
  view_de.mo  -> erkennt deutsch
  view_it.mo  -> erkennt italienisch
]]>
                </programlisting>

                <para>
                    Das erste gefundene Trennzeichen welches als Gebietsschema erkannt wird, wird verwendet.
                    Siehe das folgende Beispiel für Details.
                </para>

                <programlisting><![CDATA[
/languages
  view_en_de.mo  -> erkennt englisch
  view_en_es.mo  -> erkennt englisch und überschreibt die erste Datei
  view_it_it.mo  -> erkennt italienisch
]]>
                </programlisting>

                <para>
                    Alle drei Trennzeichen werden verwendet um das Gebietsschema zu erkennen. Das erste ist der
                    Punkt '.', das zweite ist der Unterstrich '_' und das dritte ist der Bindestrich '-'. Wenn
                    mehrere Trennzeichen im Dateinamen vorhanden sind, wird das erste gefundene, abhängig von
                    der Reihenfolge der Trennzeichen, verwendet. Siehe das folgende Beispiel für Details.
                </para>

                <programlisting><![CDATA[
/languages
  view_en-it.mo  -> erkennt englisch weil '_' vor '-' verwendet wird
  view-en_it.mo  -> erkennt italienisch weil '_' vor '-' verwendet wird
  view_en.it.mo  -> erkennt italienisch weil '.' vor '_' verwendet wird
]]>
                </programlisting>

            </sect4>

        </sect3>

    </sect2>

    <sect2 id="zend.translate.using.istranslated">

        <title>Prüfen von Übersetzungen</title>

        <para>
            Normalerweise wird Text ohne irgendwelche Berechnungen übersetzt. Aber manchmal ist es notwendig
            zu wissen ob ein Text in der Quelle übersetzt ist oder nicht. Hierzu kann die Methode
            <code>isTranslated()</code> verwendet werden.
        </para>

        <para>
            <code>isTranslated($messageId, $original = false, $locale = null)</code> nimmt als ersten Parameter
            den Text bzw die Id von der man wissen will ob sie Übersetzbar ist. Der optionale zweite Parameter
            definiert ob die Übersetzung fix für die definierte Sprache ist oder ob ein kleineres Set von
            Übersetzungen verwendet werden kann. Wenn ein Text, welcher mit 'en' übersetzt werden kann, aber nicht
            mit 'en_US', wird die Übersetzung normalerweise zurückgegeben, aber wenn <code>$original</code> auf
            true gesetzt ist, gibt die <code>isTranslated()</code> Methode in solche Fällen false zurück.
        </para>

        <example id="zend.translate.using.istranslated.example">
            <title>Prüfen ob ein Text übersetzbar ist</title>
            <programlisting role="php"><![CDATA[
$english = array('message1' => 'Nachricht 1',
                 'message2' => 'Nachricht 2',
                 'message3' => 'Nachricht 3');
$translate = new Zend_Translate('array', $english, 'de_AT');

if ($translate->isTranslated('message1')) {
    print "'message1' kann übersetzt werden";
}
if (!($translate->isTranslated('message1', true, 'de'))) {
    print "'message1' kann nicht in 'de' übersetzt werden da es " .
    "nur in 'de_AT' vorhanden ist";
}
if ($translate->isTranslated('message1', false, 'de')) {
    print "'message1' kann in 'de_AT' übersetzt werden da es zu 'de' zurückfällt";
}
]]>
            </programlisting>
        </example>

    </sect2>

    <sect2 id="zend.translate.using.sourcedata">

        <title>Zugang zu Quell Daten</title>

        <para>
            Natürlich ist es manchmal nützlich Zugang zu den übersetzten Quelldaten zu erhalten.
            Hierfür existieren zwei Methoden.
        </para>

        <para>
            Die <code>getMessageIds($locale = null)</code> Methode gibt alle bekannten Ids für
            Übersetzungen als Array zurück.
        </para>

        <para>
            Und die <code>getMessages($locale = null)</code> Methode gibt die komplette Übersetzungs-Quelle
            als Array zurück. Die Ids der Übersetzungen werden als Schlüssel und die Übersetzten Daten als
            Wert verwendet.
        </para>

        <para>
            Beide Methoden akzeptieren einen optionalen Parameter <code>$locale</code> welcher, wenn er
            gesetzt wird, die Übersetzungsdaten für die spezifizierte Sprache, zurückgibt. Wenn dieser
            Parameter nicht angegeben wird, wird die aktuell gesetzte Sprache verwendet. Es ist zu beachten
            das normalerweise alle Übersetzungen in allen Sprachen vorhanden sein sollten. Das bedeutet das
            man in einer normalen Situation diesen Parameter nicht angeben muß.
        </para>

        <para>
            Zusätzlich kann die <code>getMessages()</code> Methode das komplette Übersetzungsverzeichnis,
            mit dem Pseudo-Gebietsschema 'all', zurückgeben. Das gibt alle vorhandenen Übersetzungsdaten
            für jedes hinzugefügte Gebietsschema zurück.
        </para>

        <note>
            <para>
                Achtung: Das zurückgegebene Array kann <emphasis role="strong">sehr groß</emphasis> sein,
                abhängig von der Anzahl an hinzugefügten Gebietsschemata und der Anzahl an Übersetzungsdaten.
            </para>
        </note>

        <example id="zend.translate.using.sourcedata.example">
            <title>Handhabung von Quell Daten</title>
            <programlisting role="php"><![CDATA[
...
// gibt alle bekannten Übersetzungs Ids zurück
$messageids = $translate->getMessageIds();
print_r($messageids);

...
// oder nur die spezifizierte Sprache
$messageids = $translate->getMessageIds('en_US');
print_r($messageids);

...
// gibt die kompletten Übersetzungs Daten zurück
$source = $translate->getMessages();
print_r($source);
]]>
            </programlisting>
        </example>

    </sect2>

</sect1>
